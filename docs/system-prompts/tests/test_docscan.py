#!/usr/bin/env python3
"""
Test suite for docscan.py

Tests document integrity scanner functionality:
- Anchor extraction from markdown files
- Link target resolution (file paths + anchors)
- Broken link detection
- Section marker validation

Uses Python standard library only (no external dependencies).
"""

import unittest
import tempfile
import sys
from pathlib import Path


class TestAnchorExtraction(unittest.TestCase):
    """Test anchor extraction from markdown files."""

    def setUp(self):
        """Create temporary directory for test files."""
        self.temp_dir = tempfile.TemporaryDirectory()
        self.temp_path = Path(self.temp_dir.name)

        # Import the docscan module
        sys.path.insert(0, str(Path(__file__).parent.parent))
        from docscan import DocumentScanner

        # Create a minimal DocumentScanner instance
        import argparse
        self.args = argparse.Namespace(
            check=None,
            verbose=False
        )
        self.scanner = DocumentScanner(Path.cwd(), self.args)

    def tearDown(self):
        """Clean up temporary directory."""
        self.temp_dir.cleanup()

    def test_explicit_anchor_in_heading(self):
        """Test extraction of explicit anchor: # Heading {#custom-id}"""
        markdown = """
# My Heading {#my-custom-id}

Some content here.

# Another Heading {#another-id}
"""
        test_file = self.temp_path / "test.md"
        test_file.write_text(markdown)

        anchors = self.scanner._extract_anchors_from_file(test_file)

        self.assertIn("my-custom-id", anchors)
        self.assertIn("another-id", anchors)

    def test_autogenerated_anchor_from_heading(self):
        """Test auto-generation of anchors from heading text."""
        markdown = """
# Simple Heading

Some content.

# Heading With Multiple Words

More content.

# Heading With Dashes

Even more content.
"""
        test_file = self.temp_path / "test.md"
        test_file.write_text(markdown)

        anchors = self.scanner._extract_anchors_from_file(test_file)

        # These should be auto-generated from the heading text
        self.assertIn("simple-heading", anchors)
        self.assertIn("heading-with-multiple-words", anchors)
        self.assertIn("heading-with-dashes", anchors)

    def test_heading_with_special_characters(self):
        """Test anchor generation removes special characters."""
        markdown = """
# Hello, World!

Content.

# Test (with parentheses)

More content.

# Code: `example.py`

Even more.
"""
        test_file = self.temp_path / "test.md"
        test_file.write_text(markdown)

        anchors = self.scanner._extract_anchors_from_file(test_file)

        # Special chars should be removed, leaving dash-separated words
        self.assertIn("hello-world", anchors)
        self.assertIn("test-with-parentheses", anchors)
        self.assertIn("code-examplepy", anchors)

    def test_html_anchor_tags(self):
        """Test extraction of HTML anchor tags."""
        markdown = """
# Some Heading

<a id="html-anchor"></a>

Content here.

<a id="another-html-anchor"></a>

More content.
"""
        test_file = self.temp_path / "test.md"
        test_file.write_text(markdown)

        anchors = self.scanner._extract_anchors_from_file(test_file)

        self.assertIn("html-anchor", anchors)
        self.assertIn("another-html-anchor", anchors)

    def test_explicit_anchor_prevents_duplicate(self):
        """Test that explicit anchor prevents auto-generation."""
        markdown = """
# Heading Text {#custom-id}

Content here.
"""
        test_file = self.temp_path / "test.md"
        test_file.write_text(markdown)

        anchors = self.scanner._extract_anchors_from_file(test_file)

        # Should have explicit anchor
        self.assertIn("custom-id", anchors)
        # Should NOT have auto-generated one
        self.assertNotIn("heading-text", anchors)

    def test_anchor_caching(self):
        """Test that anchors are cached and not re-parsed."""
        markdown = "# Test Heading\n"
        test_file = self.temp_path / "test.md"
        test_file.write_text(markdown)

        # First call
        anchors1 = self.scanner._extract_anchors_from_file(test_file)
        # Second call (should use cache)
        anchors2 = self.scanner._extract_anchors_from_file(test_file)

        self.assertEqual(anchors1, anchors2)
        # Verify it's in cache
        self.assertIn(test_file, self.scanner._anchor_cache)

    def test_nonexistent_file(self):
        """Test handling of nonexistent files."""
        nonexistent = self.temp_path / "nonexistent.md"

        anchors = self.scanner._extract_anchors_from_file(nonexistent)

        self.assertEqual(anchors, set())


class TestLinkResolution(unittest.TestCase):
    """Test link target resolution."""

    def setUp(self):
        """Create test environment."""
        self.temp_dir = tempfile.TemporaryDirectory()
        self.temp_path = Path(self.temp_dir.name)

        sys.path.insert(0, str(Path(__file__).parent.parent))
        from docscan import DocumentScanner

        import argparse
        self.args = argparse.Namespace(check=None, verbose=False)
        self.scanner = DocumentScanner(self.temp_path, self.args)

    def tearDown(self):
        """Clean up."""
        self.temp_dir.cleanup()

    def test_resolve_link_with_anchor(self):
        """Test resolving link that contains anchor."""
        from_file = self.temp_path / "docs" / "current.md"
        from_file.parent.mkdir(parents=True)
        from_file.write_text("")

        link_target = "other.md#section-id"

        file_path, anchor = self.scanner._resolve_link_target(link_target, from_file)

        self.assertEqual(anchor, "section-id")
        self.assertTrue(str(file_path).endswith("other.md"))

    def test_resolve_link_without_anchor(self):
        """Test resolving link with no anchor."""
        from_file = self.temp_path / "current.md"
        from_file.write_text("")

        link_target = "other.md"

        file_path, anchor = self.scanner._resolve_link_target(link_target, from_file)

        self.assertEqual(anchor, "")
        self.assertTrue(str(file_path).endswith("other.md"))

    def test_resolve_absolute_path(self):
        """Test resolving absolute path link."""
        from_file = self.temp_path / "docs" / "current.md"
        from_file.parent.mkdir(parents=True)
        from_file.write_text("")

        link_target = "/target.md"

        file_path, anchor = self.scanner._resolve_link_target(link_target, from_file)

        self.assertTrue(str(file_path).endswith("target.md"))

    def test_resolve_relative_path(self):
        """Test resolving relative path with parent directory."""
        from_file = self.temp_path / "docs" / "subdir" / "current.md"
        from_file.parent.mkdir(parents=True)
        from_file.write_text("")

        link_target = "../other.md"

        file_path, anchor = self.scanner._resolve_link_target(link_target, from_file)

        self.assertTrue(str(file_path).endswith("other.md"))

    def test_resolve_just_anchor(self):
        """Test resolving anchor-only link (refers to same file)."""
        from_file = self.temp_path / "current.md"
        from_file.write_text("")

        link_target = "#section-id"

        file_path, anchor = self.scanner._resolve_link_target(link_target, from_file)

        self.assertEqual(file_path, from_file)
        self.assertEqual(anchor, "section-id")


class TestBrokenLinkDetection(unittest.TestCase):
    """Test broken link detection."""

    def setUp(self):
        """Create test environment."""
        self.temp_dir = tempfile.TemporaryDirectory()
        self.temp_path = Path(self.temp_dir.name)

        sys.path.insert(0, str(Path(__file__).parent.parent))
        from docscan import DocumentScanner

        import argparse
        self.args = argparse.Namespace(check=None, verbose=False)
        self.scanner = DocumentScanner(self.temp_path, self.args)

    def tearDown(self):
        """Clean up."""
        self.temp_dir.cleanup()

    def test_valid_link_no_anchor(self):
        """Test valid link without anchor."""
        # Create target file
        target = self.temp_path / "target.md"
        target.write_text("# Target\n")

        # Create source file with link
        source = self.temp_path / "source.md"
        source.write_text("[Link](target.md)\n")

        # Should not report as broken
        self.scanner._check_broken_links()

        broken_link_errors = [
            v for v in self.scanner.violations
            if v["type"] == "broken-link"
        ]
        self.assertEqual(len(broken_link_errors), 0)

    def test_valid_link_with_valid_anchor(self):
        """Test valid link with existing anchor."""
        # Create target file with anchor
        target = self.temp_path / "target.md"
        target.write_text("# Section {#my-section}\n")

        # Create source file with link to anchor
        source = self.temp_path / "source.md"
        source.write_text("[Link](target.md#my-section)\n")

        # Should not report as broken
        self.scanner._check_broken_links()

        broken_link_errors = [
            v for v in self.scanner.violations
            if v["type"] == "broken-link"
        ]
        self.assertEqual(len(broken_link_errors), 0)

    def test_broken_link_missing_file(self):
        """Test detection of link to missing file."""
        source = self.temp_path / "source.md"
        source.write_text("[Link](nonexistent.md)\n")

        self.scanner._check_broken_links()

        broken_link_errors = [
            v for v in self.scanner.violations
            if v["type"] == "broken-link" and "file not found" in v["message"]
        ]
        self.assertGreater(len(broken_link_errors), 0)

    def test_broken_link_missing_anchor(self):
        """Test detection of link to nonexistent anchor."""
        # Create target file
        target = self.temp_path / "target.md"
        target.write_text("# Existing Section {#existing}\n")

        # Create source file with link to nonexistent anchor
        source = self.temp_path / "source.md"
        source.write_text("[Link](target.md#nonexistent)\n")

        self.scanner._check_broken_links()

        # Check if any violations were recorded about missing anchors
        broken_link_errors = [
            v for v in self.scanner.violations
            if v["type"] == "broken-link"
        ]
        # At least one error should be about the anchor
        has_anchor_error = any("anchor" in v["message"].lower() for v in broken_link_errors)
        self.assertTrue(has_anchor_error or len(broken_link_errors) > 0)

    def test_external_urls_skipped(self):
        """Test that external URLs are not flagged as broken."""
        source = self.temp_path / "source.md"
        source.write_text("[Link](https://example.com)\n[Link](http://example.com)\n")

        self.scanner._check_broken_links()

        broken_link_errors = [
            v for v in self.scanner.violations
            if v["type"] == "broken-link" and "example.com" in v.get("message", "")
        ]
        self.assertEqual(len(broken_link_errors), 0)

    def test_conditional_links_skipped(self):
        """Test that links marked as conditional are not flagged."""
        target = self.temp_path / "target.md"  # File doesn't exist

        source = self.temp_path / "source.md"
        source.write_text("[Link](target.md) (if present)\n")

        self.scanner._check_broken_links()

        broken_link_errors = [
            v for v in self.scanner.violations
            if v["type"] == "broken-link" and "target.md" in v.get("message", "")
        ]
        # Should not flag as broken because of (if present)
        self.assertEqual(len(broken_link_errors), 0)


class TestMandatoryReadingAnchor(unittest.TestCase):
    """Test the specific anchor fix: mandatory-reading---read-first-every-session."""

    def setUp(self):
        """Create test environment."""
        self.temp_dir = tempfile.TemporaryDirectory()
        self.temp_path = Path(self.temp_dir.name)

        sys.path.insert(0, str(Path(__file__).parent.parent))
        from docscan import DocumentScanner

        import argparse
        self.args = argparse.Namespace(check=None, verbose=False)
        self.scanner = DocumentScanner(self.temp_path, self.args)

    def tearDown(self):
        """Clean up."""
        self.temp_dir.cleanup()

    def test_mandatory_reading_explicit_anchor(self):
        """Test extraction of the mandatory reading anchor."""
        agents = self.temp_path / "AGENTS.md"
        agents.write_text(
            "# Mandatory Reading - Read First Every Session {#mandatory-reading---read-first-every-session}\n\nContent\n"
        )

        anchors = self.scanner._extract_anchors_from_file(agents)

        self.assertIn("mandatory-reading---read-first-every-session", anchors)

    def test_mandatory_reading_autogenerated_anchor(self):
        """Test auto-generation of the mandatory reading anchor."""
        agents = self.temp_path / "AGENTS.md"
        agents.write_text(
            "# Mandatory Reading - Read First Every Session\n\nContent\n"
        )

        anchors = self.scanner._extract_anchors_from_file(agents)

        # Auto-generated version (dash becomes single dash, space becomes dash)
        self.assertIn("mandatory-reading-read-first-every-session", anchors)

    def test_tool_link_to_mandatory_reading(self):
        """Test that tool files can link to mandatory reading."""
        # Create AGENTS.md with mandatory reading section
        agents = self.temp_path / "AGENTS.md"
        agents.write_text(
            "# Mandatory Reading - Read First Every Session {#mandatory-reading---read-first-every-session}\n\nContent\n"
        )

        # Create tool file with link to it
        tool = self.temp_path / "CLAUDE.md"
        tool.write_text(
            "[AGENTS.md](AGENTS.md#mandatory-reading---read-first-every-session)\n"
        )

        self.scanner._check_broken_links()

        # Should not have any broken link errors for this anchor
        broken_mandatory = [
            v for v in self.scanner.violations
            if "mandatory-reading" in v.get("message", "")
        ]
        self.assertEqual(len(broken_mandatory), 0)


if __name__ == "__main__":
    unittest.main()
